import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt

# === ファイルパス ===
AU_CSV_PATH = "/Users/yamashita_yuma/Documents/AI_Sem/project/output/frames.csv"
COMMENT_CSV_PATH = "/Users/yamashita_yuma/Documents/AI_Sem/comment_counts.csv"

# === ハイパーパラメータ ===
learning_rate = 0.1
num_epochs = 5000
penalty_weight = -0.2
n_trials = 20

# === データ読み込み ===
df_au = pd.read_csv(AU_CSV_PATH)
df_comment = pd.read_csv(COMMENT_CSV_PATH)
df_comment.columns = ["time", "comments"]

# === AUの対象列（7種）===
target_aus = ['AU02_r', 'AU06_r', 'AU07_r', 'AU09_r', 'AU10_r', 'AU12_r', 'AU25_r']
au_data_all = df_au[target_aus].fillna(0).reset_index(drop=True)
success_flags = df_au['success'].reset_index(drop=True).values

# === コメント数：10秒ごとの値を10倍に展開（1秒ごとに同じ値を繰り返す）===
comment_counts_raw = df_comment["comments"].astype(float).values
comment_counts_expanded = np.repeat(comment_counts_raw, 10)  # 各コメント値を10回繰り返し（10fps）

# === 長さの揃え処理 ===
min_len = min(len(au_data_all), len(comment_counts_expanded))
au_data_all = au_data_all.iloc[:min_len]
success_flags = success_flags[:min_len]
comment_counts_expanded = comment_counts_expanded[:min_len]
max_comments = np.max(comment_counts_expanded)

# === Tensor化 ===
X = torch.tensor(au_data_all.values, dtype=torch.float32)
y = torch.tensor(comment_counts_expanded, dtype=torch.float32)

# === モデル定義 ===
class AULinearScorer(nn.Module):
    def __init__(self, dim):
        super().__init__()
        self.weights = nn.Parameter(torch.randn(dim))
    def forward(self, x):
        return (x * self.weights).sum(dim=1)

# === 複数回の学習で平均重みを取得 ===
all_weights = []
for trial in range(n_trials):
    model = AULinearScorer(X.shape[1])
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    for epoch in range(num_epochs):
        optimizer.zero_grad()
        pred_scores = model(X)
        pred_scores = pred_scores / pred_scores.max()

        reward = pred_scores * (y / max_comments)
        reward[:400] *= penalty_weight  # 初期40秒（10fps×40）にペナルティ

        loss = -reward.mean()
        loss.backward()
        optimizer.step()

    all_weights.append(model.weights.detach().numpy())

# === 平均重み算出 ===
mean_weights = np.mean(np.array(all_weights), axis=0)
print("🎯 平均化された重み:", mean_weights)

# === 重みでAUスコアを算出 ===
frame_scores = np.dot(au_data_all.values, mean_weights)

# === success=0 の箇所は前の値を引き継ぐ ===
frame_scores_masked = frame_scores.copy()
for i in range(1, len(frame_scores_masked)):
    if success_flags[i] == 0:
        frame_scores_masked[i] = frame_scores_masked[i-1]

# === グラフ描画 ===
plt.figure(figsize=(15, 5))
plt.plot(df_au['frame'][:len(frame_scores_masked)], frame_scores_masked, label="AU Score (Avg Weights)", color='blue')
plt.xlabel("Frame Number")
plt.ylabel("AU-Based Score")
plt.title("AU-Based Score with Averaged Weights (Masked by success, forward-filled)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# === 有効スコアのみを抽出（0を除外） ===
valid_scores = frame_scores_masked[frame_scores_masked > 0]

# === 平均と標準偏差を有効な部分から算出 ===
mean_valid = np.mean(valid_scores)
std_valid = np.std(valid_scores)

# === Zスコアを再計算（全体に対して、ただし0はそのまま） ===
z_scores = np.where(
    frame_scores_masked > 0,
    (frame_scores_masked - mean_valid) / std_valid,
    0  # 無効スコア（0）はそのまま
)

# === Zスコアのグラフ描画 ===
plt.figure(figsize=(15, 3))
plt.plot(df_au['frame'][:len(z_scores)], z_scores, color='purple', label='Z-score (Valid-based)')
plt.axhline(y=0, color='red', linestyle='--', label='Threshold = 0')
plt.xlabel("Frame Number")
plt.ylabel("Z-score")
plt.title("Z-Score of AU-Based Score (excluding 0s in mean/std)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# === パラメータ設定 ===
window_size = 60       # 30フレーム
stride = 10            # 10フレーム
threshold_percent = 90 # 90%以上

# === 対象：frame_scores_masked から z_scores を計算済みとして
frame_numbers = df_au['frame'].values[:len(z_scores)]

print("✅ 該当する区間（Zスコア > 0 が {:.0f}% 以上）:".format(threshold_percent))
for start in range(0, len(z_scores) - window_size + 1, stride):
    end = start + window_size
    window = z_scores[start:end]

    # Zスコア > 0 の割合（0を含める評価）
    ratio = (window > 0).sum() / window_size * 100

    if ratio >= threshold_percent:
        print(f"  - フレーム {frame_numbers[start]} 〜 {frame_numbers[end-1]}（Zスコア > 0 割合: {ratio:.1f} %）")
